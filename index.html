<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Blast - Puzzle Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 15px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
        }

        h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            background: linear-gradient(90deg, #ff8a00, #e52e71, #9d4edd);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 3px 20px rgba(0, 0, 0, 0.5);
            margin-bottom: 8px;
        }

        .subtitle {
            color: #b39ddb;
            font-size: clamp(0.9rem, 2vw, 1.2rem);
        }

        /* Layout utama untuk desktop */
        .game-layout {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Layout untuk tablet */
        @media (max-width: 1024px) {
            .game-layout {
                grid-template-columns: 1fr 1fr;
                grid-template-areas: 
                    "info board"
                    "next-blocks board"
                    "controls controls";
            }
            
            .game-info { grid-area: info; }
            .game-board-container { grid-area: board; }
            .next-blocks-container { grid-area: next-blocks; }
            .controls-container { grid-area: controls; }
        }

        /* Layout untuk mobile */
        @media (max-width: 768px) {
            .game-layout {
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "info"
                    "board"
                    "next-blocks"
                    "controls";
                gap: 15px;
            }
        }

        /* Panel Game Info */
        .game-info {
            background: rgba(20, 20, 40, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            border: 3px solid #9d4edd;
            backdrop-filter: blur(10px);
        }

        .game-info h2 {
            color: #ff8a00;
            margin-bottom: 15px;
            font-size: 1.4rem;
            border-bottom: 3px solid #ff8a00;
            padding-bottom: 8px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        #score-display {
            font-size: clamp(2rem, 4vw, 3rem);
            font-weight: bold;
            color: #00e5ff;
            text-align: center;
            margin: 15px 0;
            text-shadow: 0 0 20px rgba(0, 229, 255, 0.8);
            background: linear-gradient(45deg, #00e5ff, #00b8d4);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: pulse 2s infinite;
        }

        .stats p {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
        }

        .stat-label {
            color: #b39ddb;
        }

        .stat-value {
            color: #69f0ae;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(105, 240, 174, 0.5);
        }

        .difficulty-indicator {
            height: 12px;
            background: linear-gradient(90deg, #4caf50, #ff9800, #f44336);
            border-radius: 6px;
            margin-top: 8px;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .difficulty-level {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #69f0ae, #00e5ff);
            border-radius: 6px;
            transition: width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        /* Game Board */
        .game-board-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 450px;
        }

        #game-board {
            background: rgba(15, 15, 35, 0.95);
            border-radius: 20px;
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.7),
                inset 0 0 50px rgba(157, 78, 221, 0.1);
            border: 4px solid #9d4edd;
            cursor: pointer;
            width: 100%;
            max-width: 450px;
            height: auto;
            aspect-ratio: 1/1;
        }

        /* Next Blocks - SEBELAH KANAN GAME BOARD */
        .next-blocks-container {
            background: rgba(20, 20, 40, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            border: 3px solid #ff8a00;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .next-blocks-container h2 {
            color: #00e5ff;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.5rem;
            text-shadow: 0 2px 5px rgba(0, 229, 255, 0.3);
        }

        .next-blocks {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .next-block-wrapper {
            position: relative;
            cursor: grab;
            transition: all 0.3s ease;
        }

        .next-block-wrapper:hover {
            transform: scale(1.05);
        }

        .next-block-wrapper.dragging {
            opacity: 0.8;
            cursor: grabbing;
            transform: scale(0.95);
        }

        .next-block-canvas {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 3px solid #00e5ff;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: block;
        }

        .next-block-wrapper:hover .next-block-canvas {
            border-color: #ff8a00;
            box-shadow: 0 10px 25px rgba(255, 138, 0, 0.4);
        }

        /* Controls Container di BAWAH Game Board */
        .controls-container {
            grid-column: 1 / -1;
            background: rgba(20, 20, 40, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            border: 3px solid #69f0ae;
            backdrop-filter: blur(10px);
            margin-top: 10px;
        }

        .controls-container h2 {
            color: #ff8a00;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.5rem;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            justify-content: center;
        }

        button {
            background: linear-gradient(135deg, #e52e71 0%, #9d4edd 100%);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 12px;
            font-size: clamp(1rem, 2vw, 1.2rem);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(157, 78, 221, 0.4);
            position: relative;
            overflow: hidden;
            min-height: 60px;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(157, 78, 221, 0.7);
        }

        button:active {
            transform: translateY(0) scale(1);
        }

        #restart-btn {
            background: linear-gradient(135deg, #00e5ff 0%, #00b8d4 100%);
            box-shadow: 0 6px 20px rgba(0, 229, 255, 0.4);
        }

        #hint-btn {
            background: linear-gradient(135deg, #ff8a00 0%, #ff5252 100%);
            box-shadow: 0 6px 20px rgba(255, 138, 0, 0.4);
        }

        #rotate-btn {
            background: linear-gradient(135deg, #69f0ae 0%, #00c853 100%);
            box-shadow: 0 6px 20px rgba(105, 240, 174, 0.4);
        }

        /* Game Over Overlay */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 20px;
            z-index: 100;
            display: none;
            animation: fadeIn 0.5s ease-in;
            backdrop-filter: blur(5px);
        }

        .game-over h2 {
            font-size: clamp(2.5rem, 5vw, 3.5rem);
            background: linear-gradient(90deg, #ff0000, #ff8a00, #ffff00);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 0, 0, 0.7);
            animation: pulse 1.5s infinite;
        }

        .game-over p {
            font-size: clamp(1.3rem, 3vw, 1.8rem);
            margin-bottom: 20px;
            text-align: center;
        }

        .highlight {
            color: #00e5ff;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(0, 229, 255, 0.8);
        }

        /* Shadow Canvas untuk drag */
        .block-shadow {
            position: absolute;
            pointer-events: none;
            z-index: 50;
            opacity: 0.7;
            filter: blur(2px);
        }

        /* Instructions Panel */
        .instructions {
            background: rgba(20, 20, 40, 0.95);
            border-radius: 20px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            border: 3px solid #00e5ff;
            backdrop-filter: blur(10px);
        }

        .instructions h2 {
            color: #ff8a00;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.5rem;
        }

        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .instruction-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .instruction-icon {
            font-size: 1.8rem;
            color: #69f0ae;
        }

        .instruction-text {
            flex: 1;
        }

        .instruction-text strong {
            color: #00e5ff;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes scorePopup {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            50% { transform: translateY(-40px) scale(1.3); opacity: 1; }
            100% { transform: translateY(-80px) scale(0.8); opacity: 0; }
        }

        .score-popup {
            position: absolute;
            font-size: clamp(1.3rem, 2vw, 1.8rem);
            font-weight: bold;
            color: #ffeb3b;
            z-index: 5;
            pointer-events: none;
            animation: scorePopup 1.2s ease-out;
            text-shadow: 0 0 15px rgba(255, 235, 59, 0.8);
        }

        /* Mobile-specific adjustments */
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .game-info,
            .next-blocks-container,
            .controls-container,
            .instructions {
                padding: 15px;
            }
            
            .next-blocks {
                flex-direction: row;
                justify-content: center;
            }
            
            .next-block-canvas {
                width: 80px;
                height: 80px;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            button {
                padding: 12px;
            }
        }

        /* Touch-friendly adjustments */
        @media (hover: none) and (pointer: coarse) {
            button {
                padding: 20px;
                min-height: 70px;
            }
            
            .next-block-wrapper {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>BLOCK BLAST</h1>
            <p class="subtitle">Tempatkan blok warna-warni dan ledakkan baris & kolom!</p>
        </div>

        <!-- Layout utama game -->
        <div class="game-layout">
            <!-- Panel kiri: Informasi game -->
            <div class="game-info">
                <h2>‚ö° SKOR</h2>
                <div id="score-display">0</div>
                
                <div class="stats">
                    <p><span class="stat-label">üéÆ Level:</span> <span id="level" class="stat-value">1</span></p>
                    <p><span class="stat-label">üßπ Baris/Kolom:</span> <span id="lines-cleared" class="stat-value">0</span></p>
                    <p><span class="stat-label">üß© Blok Digunakan:</span> <span id="blocks-used" class="stat-value">0</span></p>
                </div>
                
                <div class="difficulty">
                    <p><span class="stat-label">üéØ Kesulitan:</span> <span id="difficulty-text" class="stat-value">Mudah</span></p>
                    <div class="difficulty-indicator">
                        <div id="difficulty-level" class="difficulty-level"></div>
                    </div>
                </div>
            </div>

            <!-- Tengah: Game Board -->
            <div class="game-board-container">
                <canvas id="game-board" width="450" height="450"></canvas>
                <div id="game-over" class="game-over">
                    <h2>GAME OVER!</h2>
                    <p>Skor Akhir: <span id="final-score" class="highlight">0</span></p>
                    <p>Baris/Kolom: <span id="final-lines" class="highlight">0</span></p>
                    <button id="play-again-btn">üéÆ MAIN LAGI</button>
                </div>
            </div>

            <!-- Kanan: Blok berikutnya (SEBELAH KANAN GAME BOARD) -->
            <div class="next-blocks-container">
                <h2>üéÅ BLOK BERIKUTNYA</h2>
                <div class="next-blocks">
                    <div class="next-block-wrapper" data-index="0">
                        <canvas id="next-block-1" width="100" height="100" class="next-block-canvas"></canvas>
                    </div>
                    <div class="next-block-wrapper" data-index="1">
                        <canvas id="next-block-2" width="100" height="100" class="next-block-canvas"></canvas>
                    </div>
                    <div class="next-block-wrapper" data-index="2">
                        <canvas id="next-block-3" width="100" height="100" class="next-block-canvas"></canvas>
                    </div>
                </div>
            </div>

            <!-- Bawah: Kontrol (DI BAWAH GAME BOARD) -->
            <div class="controls-container">
                <h2>üéÆ KONTROL</h2>
                <div class="controls-grid">
                    <button id="hint-btn">
                        <span style="font-size: 1.3em;">üîç</span><br>
                        <span>PETUNJUK</span>
                    </button>
                    <button id="rotate-btn">
                        <span style="font-size: 1.3em;">‚Üª</span><br>
                        <span>PUTAR (R)</span>
                    </button>
                    <button id="restart-btn">
                        <span style="font-size: 1.3em;">üîÑ</span><br>
                        <span>MULAI ULANG</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Panel instruksi -->
        <div class="instructions">
            <h2>üìö CARA BERMAIN</h2>
            <div class="instructions-grid">
                <div class="instruction-item">
                    <div class="instruction-icon">üé®</div>
                    <div class="instruction-text">
                        <strong>Seret dan lepaskan</strong> blok dari panel kanan ke papan game
                    </div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-icon">üëª</div>
                    <div class="instruction-text">
                        <strong>Bayangan hijau/merah</strong> menunjukkan posisi valid/tidak valid
                    </div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-icon">üí•</div>
                    <div class="instruction-text">
                        <strong>Isi baris atau kolom</strong> penuh untuk ledakkan dan dapatkan skor
                    </div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-icon">üöÄ</div>
                    <div class="instruction-text">
                        <strong>Multi-ledakan</strong> memberikan bonus combo besar!
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Warna-warni dengan gradien
        const BLOCK_COLORS = [
            { main: '#FF512F', light: '#FF8A65', dark: '#DD2C00' },
            { main: '#9D50BB', light: '#D05CE3', dark: '#6A1B9A' },
            { main: '#00B4DB', light: '#62F7FF', dark: '#0083B0' },
            { main: '#00F260', light: '#A5FECB', dark: '#0575E6' },
            { main: '#FFE000', light: '#FFEE93', dark: '#FF8008' },
            { main: '#FF5ACD', light: '#FFB7E4', dark: '#FB537B' },
            { main: '#00DBDE', light: '#88FEFE', dark: '#FC00FF' },
            { main: '#ADFF2F', light: '#E4FFA3', dark: '#32CD32' },
            { main: '#FFD700', light: '#FFEC8B', dark: '#FFA500' },
            { main: '#8A2BE2', light: '#BA98FF', dark: '#4B0082' }
        ];

        // Bentuk-bentuk blok
        const BLOCK_SHAPES = [
            [[1]], [[1, 1]], [[1], [1]],
            [[1, 0], [1, 1]], [[1, 1], [1, 0]], [[1, 1], [0, 1]], [[0, 1], [1, 1]],
            [[1, 1, 1]], [[1], [1], [1]],
            [[1, 1], [1, 1]],
            [[1, 1, 1], [0, 1, 0]], [[0, 1, 0], [1, 1, 1]],
            [[0, 1], [1, 1], [0, 1]], [[1, 0], [1, 1], [1, 0]],
            [[1, 1, 0], [0, 1, 1]], [[0, 1, 1], [1, 1, 0]],
            [[1, 1, 1, 1]], [[1], [1], [1], [1]],
            [[0, 1, 0], [1, 1, 1], [0, 1, 0]]
        ];

        class BlockBlastGame {
            constructor() {
                this.grid = Array(9).fill().map(() => Array(9).fill(0));
                this.score = 0;
                this.level = 1;
                this.linesCleared = 0;
                this.blocksUsed = 0;
                this.gameOver = false;
                this.currentBlocks = [];
                this.draggingBlock = null;
                this.dragOffset = {x: 0, y: 0};
                this.mousePos = {x: 0, y: 0};
                this.animationQueue = [];
                this.isDragging = false;
                this.blockShadowCanvas = null;
                this.blockShadowCtx = null;
                this.sparkles = [];
                this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                // Canvas elements
                this.boardCanvas = document.getElementById('game-board');
                this.boardCtx = this.boardCanvas.getContext('2d');
                
                // Adjust canvas size for mobile
                if (window.innerWidth <= 768) {
                    const size = Math.min(window.innerWidth - 40, 350);
                    this.boardCanvas.width = size;
                    this.boardCanvas.height = size;
                }
                
                this.nextCanvases = [
                    document.getElementById('next-block-1'),
                    document.getElementById('next-block-2'),
                    document.getElementById('next-block-3')
                ];
                
                this.nextCtxs = this.nextCanvases.map(c => c.getContext('2d'));
                
                // Adjust next block canvas sizes for mobile
                if (this.isMobile) {
                    this.nextCanvases.forEach(canvas => {
                        canvas.width = 80;
                        canvas.height = 80;
                    });
                }
                
                // Create shadow canvas
                this.createShadowCanvas();
                
                // Event listeners
                this.setupEventListeners();
                
                // Initialize game
                this.generateNextBlocks();
                this.draw();
                
                // Start animation loop
                this.animate();
                
                // Handle window resize
                window.addEventListener('resize', () => this.handleResize());
            }
            
            createShadowCanvas() {
                this.blockShadowCanvas = document.createElement('canvas');
                this.blockShadowCanvas.className = 'block-shadow';
                this.blockShadowCanvas.style.position = 'absolute';
                this.blockShadowCanvas.style.top = '0';
                this.blockShadowCanvas.style.left = '0';
                this.blockShadowCanvas.style.pointerEvents = 'none';
                this.blockShadowCanvas.style.zIndex = '50';
                this.blockShadowCanvas.width = this.boardCanvas.width;
                this.blockShadowCanvas.height = this.boardCanvas.height;
                
                const container = document.querySelector('.game-board-container');
                container.style.position = 'relative';
                container.appendChild(this.blockShadowCanvas);
                
                this.blockShadowCtx = this.blockShadowCanvas.getContext('2d');
            }
            
            handleResize() {
                // Adjust canvas size on resize
                if (window.innerWidth <= 768) {
                    const size = Math.min(window.innerWidth - 40, 350);
                    this.boardCanvas.width = size;
                    this.boardCanvas.height = size;
                    this.blockShadowCanvas.width = size;
                    this.blockShadowCanvas.height = size;
                } else {
                    this.boardCanvas.width = 450;
                    this.boardCanvas.height = 450;
                    this.blockShadowCanvas.width = 450;
                    this.blockShadowCanvas.height = 450;
                }
                
                this.draw();
            }
            
            setupEventListeners() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'r' || e.key === 'R') {
                        this.rotateDraggingBlock();
                    }
                });
                
                // Button controls
                document.getElementById('rotate-btn').addEventListener('click', () => this.rotateDraggingBlock());
                document.getElementById('hint-btn').addEventListener('click', () => this.showHint());
                document.getElementById('restart-btn').addEventListener('click', () => this.restartGame());
                document.getElementById('play-again-btn').addEventListener('click', () => this.restartGame());
                
                // Drag and drop with wrapper elements
                document.querySelectorAll('.next-block-wrapper').forEach((wrapper, index) => {
                    wrapper.addEventListener('mousedown', (e) => this.startDrag(e, index));
                    wrapper.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.startDrag(e, index);
                    });
                });
                
                // Mouse move for dragging
                document.addEventListener('mousemove', (e) => {
                    this.mousePos.x = e.clientX;
                    this.mousePos.y = e.clientY;
                    if (this.isDragging) {
                        this.drag(e);
                    }
                });
                
                // Touch move for dragging
                document.addEventListener('touchmove', (e) => {
                    if (!this.isDragging) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.mousePos.x = touch.clientX;
                    this.mousePos.y = touch.clientY;
                    this.drag(e);
                }, { passive: false });
                
                // Mouse up for dropping
                document.addEventListener('mouseup', (e) => {
                    if (this.isDragging) {
                        this.drop(e);
                    }
                });
                
                // Touch end for dropping
                document.addEventListener('touchend', (e) => {
                    if (this.isDragging) {
                        e.preventDefault();
                        this.drop(e);
                    }
                });
                
                // Mouse leave game board
                this.boardCanvas.addEventListener('mouseleave', () => {
                    this.clearShadow();
                });
            }
            
            generateNextBlocks() {
                this.currentBlocks = [];
                for (let i = 0; i < 3; i++) {
                    const shapeIndex = Math.floor(Math.random() * BLOCK_SHAPES.length);
                    const colorIndex = Math.floor(Math.random() * BLOCK_COLORS.length);
                    
                    this.currentBlocks.push({
                        shape: BLOCK_SHAPES[shapeIndex],
                        color: BLOCK_COLORS[colorIndex],
                        size: this.calculateBlockSize(BLOCK_SHAPES[shapeIndex]),
                        index: i
                    });
                }
                
                this.drawNextBlocks();
            }
            
            calculateBlockSize(shape) {
                return shape.flat().filter(cell => cell === 1).length;
            }
            
            drawNextBlocks() {
                this.nextCanvases.forEach((canvas, index) => {
                    const ctx = this.nextCtxs[index];
                    const block = this.currentBlocks[index];
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    if (!block) return;
                    
                    const shape = block.shape;
                    const blockWidth = shape[0].length;
                    const blockHeight = shape.length;
                    const cellSize = this.isMobile ? 25 : 30;
                    const offsetX = (canvas.width - blockWidth * cellSize) / 2;
                    const offsetY = (canvas.height - blockHeight * cellSize) / 2;
                    
                    // Draw 3D effect for each cell
                    for (let r = 0; r < blockHeight; r++) {
                        for (let c = 0; c < blockWidth; c++) {
                            if (shape[r][c] === 1) {
                                const x = offsetX + c * cellSize;
                                const y = offsetY + r * cellSize;
                                
                                // Draw cell with gradient
                                const gradient = ctx.createLinearGradient(x, y, x + cellSize - 2, y + cellSize - 2);
                                gradient.addColorStop(0, block.color.light);
                                gradient.addColorStop(0.5, block.color.main);
                                gradient.addColorStop(1, block.color.dark);
                                
                                ctx.fillStyle = gradient;
                                ctx.fillRect(x, y, cellSize - 2, cellSize - 2);
                                
                                // Draw 3D highlight
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                                ctx.fillRect(x, y, cellSize - 2, 4);
                                ctx.fillRect(x, y, 4, cellSize - 2);
                                
                                // Draw 3D shadow
                                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                                ctx.fillRect(x + cellSize - 6, y, 4, cellSize - 2);
                                ctx.fillRect(x, y + cellSize - 6, cellSize - 2, 4);
                                
                                // Draw inner glow
                                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(x + 2, y + 2, cellSize - 6, cellSize - 6);
                            }
                        }
                    }
                });
            }
            
            startDrag(e, blockIndex) {
                if (this.gameOver) return;
                
                const block = this.currentBlocks[blockIndex];
                if (!block) return;
                
                this.draggingBlock = {
                    shape: JSON.parse(JSON.stringify(block.shape)),
                    color: block.color,
                    size: block.size,
                    originalIndex: blockIndex,
                    rotation: 0
                };
                
                const wrapper = document.querySelector(`.next-block-wrapper[data-index="${blockIndex}"]`);
                const rect = wrapper.getBoundingClientRect();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                this.dragOffset = {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
                
                this.isDragging = true;
                wrapper.classList.add('dragging');
                e.preventDefault();
            }
            
            drag(e) {
                if (!this.draggingBlock || !this.isDragging) return;
                
                const clientX = e.clientX || (e.touches ? e.touches[0].clientX : this.mousePos.x);
                const clientY = e.clientY || (e.touches ? e.touches[0].clientY : this.mousePos.y);
                
                const boardRect = this.boardCanvas.getBoundingClientRect();
                const cellSize = this.boardCanvas.width / 9;
                const gridX = Math.floor((clientX - boardRect.left) / cellSize);
                const gridY = Math.floor((clientY - boardRect.top) / cellSize);
                
                this.drawBlockShadow(gridX, gridY);
            }
            
            drawBlockShadow(gridX, gridY) {
                this.blockShadowCtx.clearRect(0, 0, this.blockShadowCanvas.width, this.blockShadowCanvas.height);
                
                if (!this.draggingBlock) return;
                
                const shape = this.draggingBlock.shape;
                const cellSize = this.boardCanvas.width / 9;
                let adjustedX = gridX;
                let adjustedY = gridY;
                
                // Adjust position
                if (adjustedX + shape[0].length > 9) adjustedX = 9 - shape[0].length;
                if (adjustedY + shape.length > 9) adjustedY = 9 - shape.length;
                if (adjustedX < 0) adjustedX = 0;
                if (adjustedY < 0) adjustedY = 0;
                
                const canPlace = this.canPlaceBlock(shape, adjustedX, adjustedY);
                
                // Draw shadow cells with glow effect
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c] === 1) {
                            const x = adjustedX + c;
                            const y = adjustedY + r;
                            
                            if (x >= 0 && x < 9 && y >= 0 && y < 9) {
                                // Draw glow effect
                                this.blockShadowCtx.shadowColor = canPlace ? '#69F0AE' : '#FF5252';
                                this.blockShadowCtx.shadowBlur = 15;
                                this.blockShadowCtx.globalAlpha = canPlace ? 0.6 : 0.3;
                                
                                // Draw cell
                                this.blockShadowCtx.fillStyle = canPlace ? '#69F0AE' : '#FF5252';
                                this.blockShadowCtx.fillRect(
                                    x * cellSize + 2, 
                                    y * cellSize + 2, 
                                    cellSize - 4, 
                                    cellSize - 4
                                );
                                
                                // Reset shadow and alpha
                                this.blockShadowCtx.shadowColor = 'transparent';
                                this.blockShadowCtx.shadowBlur = 0;
                                this.blockShadowCtx.globalAlpha = 1;
                            }
                        }
                    }
                }
                
                this.targetPosition = {
                    x: adjustedX,
                    y: adjustedY,
                    valid: canPlace
                };
            }
            
            clearShadow() {
                this.blockShadowCtx.clearRect(0, 0, this.blockShadowCanvas.width, this.blockShadowCanvas.height);
            }
            
            rotateDraggingBlock() {
                if (!this.draggingBlock || !this.isDragging) return;
                
                const shape = this.draggingBlock.shape;
                const rows = shape.length;
                const cols = shape[0].length;
                const newShape = Array(cols).fill().map(() => Array(rows).fill(0));
                
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        newShape[c][rows - 1 - r] = shape[r][c];
                    }
                }
                
                this.draggingBlock.shape = newShape;
                this.draggingBlock.rotation = (this.draggingBlock.rotation + 90) % 360;
                
                // Create sparkle effect
                for (let i = 0; i < 5; i++) {
                    this.sparkles.push({
                        x: Math.random() * this.boardCanvas.width,
                        y: Math.random() * this.boardCanvas.height,
                        size: Math.random() * 3 + 2,
                        life: 1
                    });
                }
                
                if (this.targetPosition) {
                    this.drawBlockShadow(this.targetPosition.x, this.targetPosition.y);
                }
            }
            
            drop(e) {
                if (!this.draggingBlock || !this.isDragging) return;
                
                const wrapper = document.querySelector(`.next-block-wrapper[data-index="${this.draggingBlock.originalIndex}"]`);
                wrapper.classList.remove('dragging');
                this.clearShadow();
                
                if (this.targetPosition && this.targetPosition.valid) {
                    this.placeBlock(
                        this.draggingBlock.shape,
                        this.draggingBlock.color,
                        this.targetPosition.x,
                        this.targetPosition.y
                    );
                } else {
                    // Try to find valid position
                    const shape = this.draggingBlock.shape;
                    let placed = false;
                    
                    for (let radius = 0; radius <= 9; radius++) {
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const x = (this.targetPosition?.x || 0) + dx;
                                const y = (this.targetPosition?.y || 0) + dy;
                                
                                if (x >= 0 && x <= 9 - shape[0].length &&
                                    y >= 0 && y <= 9 - shape.length) {
                                    
                                    if (this.canPlaceBlock(shape, x, y)) {
                                        this.placeBlock(shape, this.draggingBlock.color, x, y);
                                        placed = true;
                                        break;
                                    }
                                }
                            }
                            if (placed) break;
                        }
                        if (placed) break;
                    }
                }
                
                this.draggingBlock = null;
                this.targetPosition = null;
                this.isDragging = false;
                this.draw();
            }
            
            canPlaceBlock(shape, gridX, gridY) {
                if (gridX < 0 || gridY < 0 || 
                    gridX + shape[0].length > 9 || 
                    gridY + shape.length > 9) {
                    return false;
                }
                
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c] === 1) {
                            if (this.grid[gridY + r][gridX + c] !== 0) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }
            
            placeBlock(shape, color, gridX, gridY) {
                // Add sparkle effect
                const cellSize = this.boardCanvas.width / 9;
                for (let i = 0; i < shape.flat().filter(cell => cell === 1).length * 2; i++) {
                    this.sparkles.push({
                        x: gridX * cellSize + Math.random() * shape[0].length * cellSize,
                        y: gridY * cellSize + Math.random() * shape.length * cellSize,
                        size: Math.random() * 4 + 1,
                        life: 1
                    });
                }
                
                // Place block on grid
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c] === 1) {
                            this.grid[gridY + r][gridX + c] = {
                                color: color,
                                placed: true
                            };
                        }
                    }
                }
                
                // Remove used block and add new one
                this.currentBlocks.splice(this.draggingBlock.originalIndex, 1);
                const shapeIndex = Math.floor(Math.random() * BLOCK_SHAPES.length);
                const colorIndex = Math.floor(Math.random() * BLOCK_COLORS.length);
                this.currentBlocks.push({
                    shape: BLOCK_SHAPES[shapeIndex],
                    color: BLOCK_COLORS[colorIndex],
                    size: this.calculateBlockSize(BLOCK_SHAPES[shapeIndex]),
                    index: this.currentBlocks.length
                });
                
                // Update stats and score
                this.blocksUsed++;
                const blockSize = this.calculateBlockSize(shape);
                const placementScore = blockSize * 15 * this.level;
                this.addScore(placementScore, gridX * cellSize + cellSize/2, gridY * cellSize + cellSize/2);
                
                // Check for completed lines
                this.checkLines();
                
                this.updateUI();
                this.drawNextBlocks();
                
                if (!this.hasValidMoves()) {
                    this.endGame();
                }
            }
            
            draw() {
                const cellSize = this.boardCanvas.width / 9;
                this.boardCtx.clearRect(0, 0, this.boardCanvas.width, this.boardCanvas.height);
                
                // Draw grid background with gradient
                const gridGradient = this.boardCtx.createLinearGradient(0, 0, 0, this.boardCanvas.height);
                gridGradient.addColorStop(0, '#0a0a1a');
                gridGradient.addColorStop(1, '#1a1a3a');
                this.boardCtx.fillStyle = gridGradient;
                this.boardCtx.fillRect(0, 0, this.boardCanvas.width, this.boardCanvas.height);
                
                // Draw grid lines
                this.boardCtx.strokeStyle = 'rgba(157, 78, 221, 0.3)';
                this.boardCtx.lineWidth = 1;
                
                for (let i = 0; i <= 9; i++) {
                    this.boardCtx.beginPath();
                    this.boardCtx.moveTo(i * cellSize, 0);
                    this.boardCtx.lineTo(i * cellSize, this.boardCanvas.height);
                    this.boardCtx.stroke();
                    
                    this.boardCtx.beginPath();
                    this.boardCtx.moveTo(0, i * cellSize);
                    this.boardCtx.lineTo(this.boardCanvas.width, i * cellSize);
                    this.boardCtx.stroke();
                }
                
                // Draw placed blocks
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.grid[r][c] !== 0) {
                            const block = this.grid[r][c];
                            const x = c * cellSize;
                            const y = r * cellSize;
                            
                            // Draw main block with gradient
                            const gradient = this.boardCtx.createLinearGradient(x, y, x + cellSize, y + cellSize);
                            gradient.addColorStop(0, block.color.light);
                            gradient.addColorStop(0.5, block.color.main);
                            gradient.addColorStop(1, block.color.dark);
                            
                            this.boardCtx.fillStyle = gradient;
                            this.boardCtx.fillRect(x + 2, y + 2, cellSize - 4, cellSize - 4);
                            
                            // Draw 3D highlight
                            this.boardCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                            this.boardCtx.fillRect(x + 2, y + 2, cellSize - 4, cellSize * 0.15);
                            this.boardCtx.fillRect(x + 2, y + 2, cellSize * 0.15, cellSize - 4);
                            
                            // Draw 3D shadow
                            this.boardCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                            this.boardCtx.fillRect(x + cellSize - cellSize * 0.15 - 2, y + 2, cellSize * 0.15, cellSize - 4);
                            this.boardCtx.fillRect(x + 2, y + cellSize - cellSize * 0.15 - 2, cellSize - 4, cellSize * 0.15);
                        }
                    }
                }
                
                // Draw sparkles
                for (let i = this.sparkles.length - 1; i >= 0; i--) {
                    const sparkle = this.sparkles[i];
                    this.boardCtx.globalAlpha = sparkle.life;
                    this.boardCtx.fillStyle = sparkle.color || '#FFFFFF';
                    this.boardCtx.beginPath();
                    this.boardCtx.arc(sparkle.x, sparkle.y, sparkle.size, 0, Math.PI * 2);
                    this.boardCtx.fill();
                    sparkle.life -= 0.02;
                    
                    if (sparkle.life <= 0) {
                        this.sparkles.splice(i, 1);
                    }
                }
                this.boardCtx.globalAlpha = 1;
                
                // Draw animations
                this.drawAnimations();
            }
            
            checkLines() {
                const completedRows = [];
                const completedCols = [];
                
                for (let r = 0; r < 9; r++) {
                    let rowComplete = true;
                    for (let c = 0; c < 9; c++) {
                        if (this.grid[r][c] === 0) {
                            rowComplete = false;
                            break;
                        }
                    }
                    if (rowComplete) completedRows.push(r);
                }
                
                for (let c = 0; c < 9; c++) {
                    let colComplete = true;
                    for (let r = 0; r < 9; r++) {
                        if (this.grid[r][c] === 0) {
                            colComplete = false;
                            break;
                        }
                    }
                    if (colComplete) completedCols.push(c);
                }
                
                if (completedRows.length > 0 || completedCols.length > 0) {
                    // Create explosion effect
                    for (let i = 0; i < 30; i++) {
                        this.sparkles.push({
                            x: Math.random() * this.boardCanvas.width,
                            y: Math.random() * this.boardCanvas.height,
                            size: Math.random() * 6 + 2,
                            life: 1,
                            color: ['#FF5252', '#FFEB3B', '#00E5FF', '#69F0AE'][Math.floor(Math.random() * 4)]
                        });
                    }
                    
                    this.animationQueue.push({
                        type: 'lineClear',
                        rows: completedRows,
                        cols: completedCols,
                        duration: 30
                    });
                    
                    const totalLines = completedRows.length + completedCols.length;
                    let lineScore = totalLines * 150 * this.level;
                    
                    if (totalLines > 1) {
                        lineScore += (totalLines - 1) * 75 * this.level;
                    }
                    
                    if (completedRows.length > 0 && completedCols.length > 0) {
                        lineScore += 300 * this.level;
                    }
                    
                    const cellSize = this.boardCanvas.width / 9;
                    this.addScore(lineScore, this.boardCanvas.width/2, this.boardCanvas.height/2);
                    this.linesCleared += totalLines;
                    
                    if (this.linesCleared >= this.level * 10) {
                        this.levelUp();
                    }
                    
                    setTimeout(() => {
                        completedRows.forEach(r => {
                            for (let c = 0; c < 9; c++) {
                                this.grid[r][c] = 0;
                            }
                        });
                        
                        completedCols.forEach(c => {
                            for (let r = 0; r < 9; r++) {
                                this.grid[r][c] = 0;
                            }
                        });
                        
                        this.updateUI();
                        this.draw();
                    }, 500);
                }
            }
            
            addScore(points, x, y) {
                this.score += points;
                
                const popup = document.createElement('div');
                popup.className = 'score-popup';
                popup.textContent = `+${points}`;
                popup.style.left = `${x}px`;
                popup.style.top = `${y}px`;
                
                document.querySelector('.game-board-container').appendChild(popup);
                
                setTimeout(() => {
                    popup.remove();
                }, 1200);
                
                this.updateUI();
            }
            
            levelUp() {
                this.level++;
                
                const difficultyLevel = document.getElementById('difficulty-level');
                const difficultyPercent = Math.min(100, (this.level - 1) * 20);
                difficultyLevel.style.width = `${difficultyPercent}%`;
                
                const difficultyText = document.getElementById('difficulty-text');
                if (this.level <= 3) {
                    difficultyText.textContent = "Mudah";
                    difficultyText.style.color = "#4caf50";
                } else if (this.level <= 6) {
                    difficultyText.textContent = "Sedang";
                    difficultyText.style.color = "#ff9800";
                } else {
                    difficultyText.textContent = "Sulit";
                    difficultyText.style.color = "#f44336";
                }
                
                // Create level up sparkles
                for (let i = 0; i < 20; i++) {
                    this.sparkles.push({
                        x: Math.random() * this.boardCanvas.width,
                        y: Math.random() * this.boardCanvas.height,
                        size: Math.random() * 5 + 3,
                        life: 1.5,
                        color: '#FFD700'
                    });
                }
                
                this.animationQueue.push({
                    type: 'levelUp',
                    level: this.level,
                    duration: 60
                });
            }
            
            showHint() {
                for (let block of this.currentBlocks) {
                    const shape = block.shape;
                    
                    for (let y = 0; y <= 9 - shape.length; y++) {
                        for (let x = 0; x <= 9 - shape[0].length; x++) {
                            if (this.canPlaceBlock(shape, x, y)) {
                                // Show sparkles at hint location
                                const cellSize = this.boardCanvas.width / 9;
                                for (let i = 0; i < 15; i++) {
                                    this.sparkles.push({
                                        x: (x + Math.random() * shape[0].length) * cellSize,
                                        y: (y + Math.random() * shape.length) * cellSize,
                                        size: Math.random() * 4 + 2,
                                        life: 1,
                                        color: '#00E5FF'
                                    });
                                }
                                return;
                            }
                        }
                    }
                }
                
                this.animationQueue.push({
                    type: 'noMoves',
                    duration: 30
                });
            }
            
            drawAnimations() {
                for (let i = this.animationQueue.length - 1; i >= 0; i--) {
                    const animation = this.animationQueue[i];
                    
                    if (animation.type === 'lineClear') {
                        this.drawLineClearAnimation(animation);
                        animation.duration--;
                        
                        if (animation.duration <= 0) {
                            this.animationQueue.splice(i, 1);
                        }
                    } else if (animation.type === 'levelUp') {
                        this.drawLevelUpAnimation(animation);
                        animation.duration--;
                        
                        if (animation.duration <= 0) {
                            this.animationQueue.splice(i, 1);
                        }
                    }
                }
            }
            
            drawLineClearAnimation(animation) {
                const frame = animation.duration;
                const alpha = frame % 10 < 5 ? 0.8 : 0.3;
                const cellSize = this.boardCanvas.width / 9;
                
                this.boardCtx.globalAlpha = alpha;
                this.boardCtx.fillStyle = "#69F0AE";
                this.boardCtx.shadowColor = "#69F0AE";
                this.boardCtx.shadowBlur = 20;
                
                animation.rows.forEach(row => {
                    this.boardCtx.fillRect(0, row * cellSize, this.boardCanvas.width, cellSize);
                });
                
                animation.cols.forEach(col => {
                    this.boardCtx.fillRect(col * cellSize, 0, cellSize, this.boardCanvas.height);
                });
                
                this.boardCtx.shadowColor = 'transparent';
                this.boardCtx.shadowBlur = 0;
                this.boardCtx.globalAlpha = 1;
            }
            
            drawLevelUpAnimation(animation) {
                const frame = animation.duration;
                const scale = 1 + Math.sin(frame * 0.2) * 0.1;
                
                this.boardCtx.save();
                this.boardCtx.translate(this.boardCanvas.width/2, this.boardCanvas.height/2);
                this.boardCtx.scale(scale, scale);
                
                this.boardCtx.font = `bold ${Math.min(50, this.boardCanvas.width / 10)}px Arial`;
                const gradient = this.boardCtx.createLinearGradient(-100, 0, 100, 0);
                gradient.addColorStop(0, "#FFD700");
                gradient.addColorStop(0.5, "#FF8A00");
                gradient.addColorStop(1, "#FFD700");
                
                this.boardCtx.fillStyle = gradient;
                this.boardCtx.textAlign = "center";
                this.boardCtx.textBaseline = "middle";
                this.boardCtx.shadowColor = "#FFD700";
                this.boardCtx.shadowBlur = 30;
                this.boardCtx.fillText(`LEVEL ${animation.level}`, 0, 0);
                
                this.boardCtx.restore();
            }
            
            hasValidMoves() {
                for (let block of this.currentBlocks) {
                    const shape = block.shape;
                    
                    for (let y = 0; y <= 9 - shape.length; y++) {
                        for (let x = 0; x <= 9 - shape[0].length; x++) {
                            if (this.canPlaceBlock(shape, x, y)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            endGame() {
                this.gameOver = true;
                
                // Create game over sparkles
                for (let i = 0; i < 50; i++) {
                    this.sparkles.push({
                        x: Math.random() * this.boardCanvas.width,
                        y: Math.random() * this.boardCanvas.height,
                        size: Math.random() * 8 + 4,
                        life: 2,
                        color: ['#FF0000', '#FF8A00', '#FFFF00'][Math.floor(Math.random() * 3)]
                    });
                }
                
                document.getElementById('final-score').textContent = this.score;
                document.getElementById('final-lines').textContent = this.linesCleared;
                document.getElementById('game-over').style.display = 'flex';
            }
            
            restartGame() {
                this.grid = Array(9).fill().map(() => Array(9).fill(0));
                this.score = 0;
                this.level = 1;
                this.linesCleared = 0;
                this.blocksUsed = 0;
                this.gameOver = false;
                this.currentBlocks = [];
                this.draggingBlock = null;
                this.sparkles = [];
                this.animationQueue = [];
                this.isDragging = false;
                
                this.clearShadow();
                
                document.getElementById('difficulty-level').style.width = '0%';
                document.getElementById('difficulty-text').textContent = "Mudah";
                document.getElementById('difficulty-text').style.color = "#4caf50";
                
                document.getElementById('game-over').style.display = 'none';
                
                this.generateNextBlocks();
                this.updateUI();
                this.draw();
            }
            
            updateUI() {
                document.getElementById('score-display').textContent = this.score.toLocaleString();
                document.getElementById('level').textContent = this.level;
                document.getElementById('lines-cleared').textContent = this.linesCleared;
                document.getElementById('blocks-used').textContent = this.blocksUsed;
            }
            
            animate() {
                this.draw();
                requestAnimationFrame(() => this.animate());
            }
        }

        window.addEventListener('load', () => {
            const game = new BlockBlastGame();
            window.game = game;
        });
    </script>
</body>
</html>